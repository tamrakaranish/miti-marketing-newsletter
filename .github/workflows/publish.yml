name: "Publish Newsletter"

on:
  push:
    branches: [ main ]  # Only auto-publish from main branch (production)
    paths:
      - "newsletter/20*.md"  # Only trigger for actual newsletter files (not examples)
      - "!newsletter/*-test*.md"  # Exclude test newsletters
      - "!newsletter/*-draft*.md"  # Exclude draft newsletters
      - "!newsletter/*-manual*.md"  # Exclude manually generated newsletters
  workflow_dispatch:  # Allow manual triggering from any branch
    inputs:
      environment:
        description: 'Choose environment for manual publishing'
        required: true
        default: 'test'
        type: choice
        options:
        - test
        - production
      newsletter_date:
        description: 'Newsletter date (YYYY-MM-DD) or leave empty for latest'
        required: false
        type: string
      list_available:
        description: 'Just list available newsletters (for reference)'
        required: false
        default: false
        type: boolean

permissions:
  contents: write  # Need write permissions to delete branches

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Determine target environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Manual trigger - use selected environment
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "üéØ Manual publish ‚Üí ${{ inputs.environment }} environment"
          else
            # Auto-triggered by push to main - always production
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "üöÄ Auto-triggered from main branch ‚Üí PRODUCTION"
            echo "‚úÖ PR was reviewed and approved, publishing to production"
          fi
      
      - name: Validate Slack channel configuration
        run: |
          ENV="${{ steps.env.outputs.environment }}"
          if [ "$ENV" = "production" ]; then
            CHANNEL="${{ vars.SLACK_CHANNEL_PRODUCTION || '#mitigram-ai' }}"
            echo "‚úÖ Production channel: $CHANNEL"
            if [ "$CHANNEL" = "#mitigram-ai" ]; then
              echo "‚ö†Ô∏è  Using fallback production channel. Consider setting SLACK_CHANNEL_PRODUCTION variable."
            fi
          else
            CHANNEL="${{ vars.SLACK_CHANNEL_TEST || '#ai-publish-test' }}"
            echo "‚úÖ Test channel: $CHANNEL"
            if [ "$CHANNEL" = "#ai-publish-test" ]; then
              echo "‚ö†Ô∏è  Using fallback test channel. Consider setting SLACK_CHANNEL_TEST variable."
            fi
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Locate newsletter files
        id: find
        shell: bash
        run: |
          set -euo pipefail
          
          # If just listing available newsletters, show them and exit
          if [ "${{ inputs.list_available }}" = "true" ]; then
            echo "üìã Available newsletters:"
            echo ""
            echo "üì∞ Scheduled newsletters (auto-publish):"
            ls -1 newsletter/*.md 2>/dev/null | grep -E '/[0-9]{4}-[0-9]{2}-[0-9]{2}\.md$' | sort | tail -10 || echo "  None found"
            echo ""
            echo "üöÄ Manual newsletters (manual publish):"
            ls -1 newsletter/*.md 2>/dev/null | grep -E '/[0-9]{4}-[0-9]{2}-[0-9]{2}-manual-' | sort | tail -10 || echo "  None found"
            echo ""
            echo "üß™ Test newsletters:"
            ls -1 newsletter/*.md 2>/dev/null | grep -E '/[0-9]{4}-[0-9]{2}-[0-9]{2}-test-' | sort | tail -10 || echo "  None found"
            echo ""
            echo "üí° To publish a newsletter, rerun this workflow without the 'list_available' option"
            exit 0
          fi
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.newsletter_date }}" ]; then
            # Manual trigger with specific date
            TARGET_DATE="${{ inputs.newsletter_date }}"
            
            # Validate date format
            if ! echo "$TARGET_DATE" | grep -qE '^[0-9]{4}-[0-9]{2}-[0-9]{2}$'; then
              echo "‚ùå Invalid date format: '$TARGET_DATE'"
              echo "Expected format: YYYY-MM-DD (e.g., 2025-01-06)"
              exit 1
            fi
            
            # Find newsletter file for the specified date (any type)
            echo "üîç Looking for newsletters from $TARGET_DATE..."
            FOUND_FILES=($(ls newsletter/${TARGET_DATE}*.md 2>/dev/null || true))
            
            if [ ${#FOUND_FILES[@]} -eq 0 ]; then
              echo "‚ùå No newsletters found for date: $TARGET_DATE"
              echo ""
              echo "üìã Available newsletters:"
              ls -1 newsletter/*.md 2>/dev/null | grep -E '/[0-9]{4}-[0-9]{2}-[0-9]{2}' | sort | tail -10 || echo "None found"
              echo ""
              echo "üí° Tip: Leave newsletter_date empty to use the latest newsletter"
              exit 1
            elif [ ${#FOUND_FILES[@]} -eq 1 ]; then
              MD="${FOUND_FILES[0]}"
              echo "‚úÖ Found newsletter: $MD"
            else
              echo "üìã Multiple newsletters found for $TARGET_DATE:"
              for i in "${!FOUND_FILES[@]}"; do
                echo "  $((i+1)). ${FOUND_FILES[i]}"
              done
              # Use the most recent (last in array when sorted)
              MD="$(printf '%s\n' "${FOUND_FILES[@]}" | sort | tail -n 1)"
              echo "üéØ Using most recent: $MD"
            fi
            
            TXT="${MD%.md}_slack.txt"
          else
            # Auto-triggered or manual without date - use latest newsletter (any type)
            echo "üîç Finding latest newsletter..."
            
            if [ "${{ github.event_name }}" = "push" ]; then
              # Auto-triggered by push - only look for scheduled files (exact date format)
              MD="$(ls -1 newsletter/*.md 2>/dev/null | grep -E '/[0-9]{4}-[0-9]{2}-[0-9]{2}\.md$' | sort | tail -n 1 || true)"
              echo "üöÄ Auto-trigger: Looking for scheduled newsletters only"
            else
              # Manual trigger without date - include all newsletter types
              MD="$(ls -1 newsletter/*.md 2>/dev/null | grep -E '/[0-9]{4}-[0-9]{2}-[0-9]{2}' | sort | tail -n 1 || true)"
              echo "üéØ Manual trigger: Looking for any newsletter type"
            fi
            
            [ -z "${MD:-}" ] && { echo "‚ùå No newsletter files found"; exit 1; }
            TXT="${MD%.md}_slack.txt"
            echo "üìÑ Using latest newsletter: $MD"
          fi
      
          # Set output variables
          SLACK="$TXT"
          echo "Selected MD: $MD"
          [ -f "$SLACK" ] && echo "Matching Slack exists: $SLACK" || echo "Slack will be generated: $SLACK"
      
          echo "file_md=$MD" >> "$GITHUB_OUTPUT"
          echo "file_slack=$SLACK" >> "$GITHUB_OUTPUT"


      - name: Ensure Slack text exists (fallback generator)
        shell: bash
        run: |
          set -euo pipefail
          MD="${{ steps.find.outputs.file_md }}"
          SLACK="${{ steps.find.outputs.file_slack }}"
          if [ ! -f "$SLACK" ]; then
            echo "Generating Slack text from $MD ‚Üí $SLACK"
            export MD SLACK
            python scripts/format_slack.py
          else
            echo "Slack file already exists: $SLACK"
          fi

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Create new Confluence post
        env:
          CF_BASE:  ${{ secrets.CONFLUENCE_BASE_URL }}     # e.g. https://yourcompany.atlassian.net
          CF_USER:  ${{ secrets.CONFLUENCE_USER }}          # Atlassian email
          CF_TOKEN: ${{ secrets.CONFLUENCE_API_TOKEN }}     # Atlassian API token
          CF_SPACE_KEY: ${{ secrets.CONFLUENCE_SPACE_KEY }} # Space key (e.g. "NEWSLETTER")
          FILE_MD: ${{ steps.find.outputs.file_md }}
        shell: bash
        run: |
          set -euo pipefail
          for v in CF_BASE CF_USER CF_TOKEN CF_SPACE_KEY; do
            if [ -z "${!v:-}" ]; then echo "$v is not set"; exit 1; fi
          done

          # Convert markdown to Confluence storage format
          MD_CONTENT="$(cat "$FILE_MD")"
          HTML_CONTENT="$(echo "$MD_CONTENT" | sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g')"
          
          # Convert markdown formatting to Confluence markup
          HTML_CONTENT="$(echo "$HTML_CONTENT" | sed -E 's/^# (.*)/\<h1\>\1\<\/h1\>/g')"
          HTML_CONTENT="$(echo "$HTML_CONTENT" | sed -E 's/^## (.*)/\<h2\>\1\<\/h2\>/g')"
          HTML_CONTENT="$(echo "$HTML_CONTENT" | sed -E 's/^### (.*)/\<h3\>\1\<\/h3\>/g')"
          HTML_CONTENT="$(echo "$HTML_CONTENT" | sed -E 's/\*\*(.*?)\*\*/\<strong\>\1\<\/strong\>/g')"
          HTML_CONTENT="$(echo "$HTML_CONTENT" | sed -E 's/\[(.*?)\]\((.*?)\)/\<a href=\"\2\"\>\1\<\/a\>/g')"
          HTML_CONTENT="$(echo "$HTML_CONTENT" | sed -E 's/^- (.*)/\<li\>\1\<\/li\>/g')"
          
          # Wrap in proper Confluence storage format
          STORAGE_CONTENT="<p>$HTML_CONTENT</p>"
          
          # Create unique title with date
          DATE_PART="$(basename "$FILE_MD" .md)"
          TITLE="MitiMind AI Newsletter - $DATE_PART"

          # Check if page already exists
          EXISTING="$(curl -s -u "$CF_USER:$CF_TOKEN" \
            "$CF_BASE/wiki/rest/api/content?spaceKey=$CF_SPACE_KEY&title=$(echo "$TITLE" | sed 's/ /%20/g')" | \
            jq -r '.results | length')"
          
          if [ "$EXISTING" -gt 0 ]; then
            echo "‚ö†Ô∏è  Page '$TITLE' already exists. Skipping Confluence creation."
            echo "üîç This might be a duplicate run or the page was manually created."
            # Use existing page for Slack link
            EXISTING_URL="$(curl -s -u "$CF_USER:$CF_TOKEN" \
              "$CF_BASE/wiki/rest/api/content?spaceKey=$CF_SPACE_KEY&title=$(echo "$TITLE" | sed 's/ /%20/g')" | \
              jq -r '.results[0]._links.webui')"
            CONFLUENCE_URL="$CF_BASE/wiki$EXISTING_URL"
            echo "CONFLUENCE_URL=$CONFLUENCE_URL" >> "$GITHUB_ENV"
            echo "üìñ Using existing page: $CONFLUENCE_URL"
          else
            echo "‚úÖ Creating new page: $TITLE"

          # Create new page payload
          DATA="$(jq -n \
            --arg title "$TITLE" \
            --arg spaceKey "$CF_SPACE_KEY" \
            --arg body "$STORAGE_CONTENT" \
            '{
              type: "page",
              title: $title,
              space: { key: $spaceKey },
              body: {
                storage: {
                  value: $body,
                  representation: "storage"
                }
              }
            }')"

          # Create new page (POST, not PUT)
          RESP="$(curl -s -w '\n%{http_code}' -u "$CF_USER:$CF_TOKEN" \
            -X POST "$CF_BASE/wiki/rest/api/content" \
            -H "Content-Type: application/json" \
            --data "$DATA")"

          BODY="$(echo "$RESP" | head -n1)"
          CODE="$(echo "$RESP" | tail -n1)"

          echo "Confluence HTTP: $CODE"
          echo "Confluence Body:"; echo "$BODY" | jq .

          if [ "$CODE" -lt 200 ] || [ "$CODE" -ge 300 ]; then
            echo "Confluence post creation failed"; exit 1
          fi

          echo "Created new page:"
          echo "Title: $(echo "$BODY" | jq -r '.title')"
          echo "ID: $(echo "$BODY" | jq -r '.id')"
          CONFLUENCE_URL="$CF_BASE/wiki$(echo "$BODY" | jq -r '._links.webui')"
          echo "URL: $CONFLUENCE_URL"
          
          # Save Confluence URL for Slack step
          echo "CONFLUENCE_URL=$CONFLUENCE_URL" >> "$GITHUB_ENV"
          fi  # End of else block for page creation

      - name: Post newsletter to Slack with Confluence link
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          FILE_SLACK: ${{ steps.find.outputs.file_slack }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${SLACK_BOT_TOKEN:-}" ]; then
            echo "SLACK_BOT_TOKEN is not set"; exit 1
          fi
          if [ ! -f "$FILE_SLACK" ]; then
            echo "‚ö†Ô∏è  Slack file missing: $FILE_SLACK"
            echo "üîÑ Generating Slack version from Markdown..."
            
            MD_FILE="${{ steps.find.outputs.file_md }}"
            if [ ! -f "$MD_FILE" ]; then
              echo "‚ùå Markdown file also missing: $MD_FILE"; exit 1
            fi
            
            # Generate Slack version using format_slack.py
            python scripts/format_slack.py "$MD_FILE" "$FILE_SLACK"
            echo "‚úÖ Generated missing Slack file: $FILE_SLACK"
          fi
          
          # Determine Slack channel based on environment
          ENV="${{ steps.env.outputs.environment }}"
          if [ "$ENV" = "production" ]; then
            SLACK_CHANNEL="${{ vars.SLACK_CHANNEL_PRODUCTION }}"
            if [ -z "$SLACK_CHANNEL" ]; then
              echo "‚ùå SLACK_CHANNEL_PRODUCTION variable is not set!"
              echo "Please set it in GitHub ‚Üí Settings ‚Üí Variables"
              exit 1
            fi
          else
            SLACK_CHANNEL="${{ vars.SLACK_CHANNEL_TEST }}"
            if [ -z "$SLACK_CHANNEL" ]; then
              echo "‚ùå SLACK_CHANNEL_TEST variable is not set!"
              echo "Please set it in GitHub ‚Üí Settings ‚Üí Variables"
              exit 1
            fi
          fi
          echo "üì± Publishing to Slack channel: $SLACK_CHANNEL"
          
          # Read newsletter content and add Confluence link
          TEXT="$(cat "$FILE_SLACK")"
          if [ -n "${CONFLUENCE_URL:-}" ]; then
            TEXT="$TEXT"$'\n\n'"üìñ *Read the full newsletter in Confluence:* $CONFLUENCE_URL"
          fi
          
          JSON="$(jq -n --arg ch "$SLACK_CHANNEL" --arg txt "$TEXT" \
            '{channel:$ch, text:$txt, unfurl_links:false}')"
          RESP="$(curl -s -w '\n%{http_code}' -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$JSON")"
          BODY="$(echo "$RESP" | head -n1)"
          CODE="$(echo "$RESP" | tail -n1)"
          echo "Slack HTTP: $CODE"
          echo "Slack Body:"; echo "$BODY" | jq .
          OK="$(echo "$BODY" | jq -r '.ok // false')"
          if [ "$OK" != "true" ]; then
            echo "Slack post failed"; exit 1
          fi
          
      - name: Cleanup newsletter branches
        shell: bash
        run: |
          # Delete any newsletter/draft-* branches that have been merged (run after publishing)
          echo "üßπ Cleaning up old newsletter branches..."
          BRANCHES=$(git branch -r | grep "origin/newsletter/draft-" | sed 's/origin\///' || true)
          if [ -n "$BRANCHES" ]; then
            echo "$BRANCHES" | xargs -I {} git push origin --delete {} || true
            echo "‚úÖ Deleted $(echo "$BRANCHES" | wc -l) newsletter branches"
          else
            echo "‚úÖ No newsletter branches to clean up"
          fi
