name: Publish Newsletter

on:
  push:
    branches: [ main ]
    paths:
      - "newsletter/*.md"

permissions:
  contents: read

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Find latest newsletter files (with fallback if Slack file missing)
        id: find
        shell: bash
        run: |
          set -euo pipefail

          echo "== Repo state =="
          ls -la
          echo "== newsletter/ =="
          ls -la newsletter || true

          MD="$(ls -1t newsletter/*.md | head -n 1 || true)"
          if [ -z "${MD:-}" ]; then
            echo "No newsletter/*.md found"; exit 1
          fi
          SLACK="${MD%.md}_slack.txt"

          echo "Found MD: $MD"
          if [ -f "$SLACK" ]; then
            echo "Found Slack: $SLACK"
          else
            echo "Slack file not found, generating from MD → $SLACK"

            python - <<'PY'
import os, re, sys, html
md_path = os.environ["MD"]
slack_path = os.environ["SLACK"]

with open(md_path, "r", encoding="utf-8") as f:
    md = f.read()

# Headings (# ..) -> bold, with simple emojis for known sections
hdr = re.compile(r'^(#{1,6})\s+(.*)$', re.M)
def add_emoji(title: str) -> str:
    t = title.lower()
    if "ai in trade finance" in t: return f"📢 {title}"
    if "tip of the week" in t:     return f"💡 {title}"
    if "internal spotlight" in t:  return f"🔍 {title}"
    if "quick hits" in t:          return f"⚡ {title}"
    if "mitimind" in t or "newsletter" in t: return f"🗞️ {title}"
    return title

md = hdr.sub(lambda m: f"*{add_emoji(m.group(2).strip())}*", md)

# Bullets: "- " at line start -> "• "
md = re.sub(r'(?m)^\s*-\s+', "• ", md)

# Links: [text](url) -> <url|text>
md = re.sub(r'\[([^\]]+)\]\((https?://[^)]+)\)', r'<\2|\1>', md)

with open(slack_path, "w", encoding="utf-8") as f:
    f.write(md)
    f.write("\n\n_Read the full issue in Confluence once published._")
print("Wrote Slack file:", slack_path)
PY
          fi

          # Export for downstream steps
          echo "file_md=$MD" >> "$GITHUB_OUTPUT"
          echo "file_slack=$SLACK" >> "$GITHUB_OUTPUT"

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Post full message to Slack
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: "#ai-newsletter"   # <-- change if needed
          FILE_SLACK: ${{ steps.find.outputs.file_slack }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${SLACK_BOT_TOKEN:-}" ]; then
            echo "SLACK_BOT_TOKEN is not set"; exit 1
          fi
          TEXT="$(cat "$FILE_SLACK")"
          JSON="$(jq -n --arg ch "$SLACK_CHANNEL" --arg txt "$TEXT" \
            '{channel:$ch, text:$txt, unfurl_links:false}')"
          RESP="$(curl -s -w '\n%{http_code}' -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$JSON")"
          BODY="$(echo "$RESP" | head -n1)"
          CODE="$(echo "$RESP" | tail -n1)"
          echo "Slack HTTP: $CODE"
          echo "Slack Body:"; echo "$BODY" | jq .
          OK="$(echo "$BODY" | jq -r '.ok // false')"
          if [ "$OK" != "true" ]; then
            echo "Slack post failed"; exit 1
          fi

      - name: Update Confluence archive (v1 API)
        env:
          CF_BASE:  ${{ secrets.CONFLUENCE_BASE_URL }}   # e.g. https://yourcompany.atlassian.net
          CF_USER:  ${{ secrets.CONFLUENCE_USER }}        # Atlassian email
          CF_TOKEN: ${{ secrets.CONFLUENCE_API_TOKEN }}   # Atlassian API token
          CF_PAGE_ID: ${{ secrets.CONFLUENCE_PAGE_ID }}   # numeric page id
          FILE_MD: ${{ steps.find.outputs.file_md }}
        shell: bash
        run: |
          set -euo pipefail
          for v in CF_BASE CF_USER CF_TOKEN CF_PAGE_ID; do
            if [ -z "${!v:-}" ]; then echo "$v is not set"; exit 1; fi
          done

          HTML_CONTENT="$(printf '<pre>%s</pre>' "$(sed 's/&/\&amp;/g; s/</\&lt;/g; s/>/\&gt;/g' "$FILE_MD")")"
          TITLE="$(basename "$FILE_MD" .md): MitiMind"

          CURR="$(curl -s -u "$CF_USER:$CF_TOKEN" \
            "$CF_BASE/wiki/rest/api/content/$CF_PAGE_ID?expand=version")"
          if [ -z "$CURR" ]; then echo "Empty response from Confluence (version read)"; exit 1; fi
          VER="$(echo "$CURR" | jq -r '.version.number // 1')"
          NEW=$((VER+1))

          DATA="$(jq -n --arg title "$TITLE" --arg body "$HTML_CONTENT" --argjson ver "$NEW" \
            '{title:$title, type:"page", version:{number:$ver}, body:{storage:{value:$body, representation:"storage"}}}')"

          RESP="$(curl -s -w '\n%{http_code}' -u "$CF_USER:$CF_TOKEN" \
            -X PUT "$CF_BASE/wiki/rest/api/content/$CF_PAGE_ID" \
            -H "Content-Type: application/json" \
            --data "$DATA")"

          BODY="$(echo "$RESP" | head -n1)"
          CODE="$(echo "$RESP" | tail -n1)"

          echo "Confluence HTTP: $CODE"
          echo "Confluence Body:"; echo "$BODY" | jq .

          if [ "$CODE" -lt 200 ] || [ "$CODE" -ge 300 ]; then
            echo "Confluence update failed"; exit 1
          fi

          echo "Updated page title:"; echo "$BODY" | jq -r '.title'
          echo "New version:"; echo "$BODY" | jq -r '.version.number'
